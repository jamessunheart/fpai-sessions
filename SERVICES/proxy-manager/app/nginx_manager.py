"""NGINX configuration management."""
import os
import subprocess
import logging
from pathlib import Path
from typing import Optional, Tuple
from datetime import datetime

from app.models import ProxyConfig
from app.config import settings

logger = logging.getLogger(__name__)


class NGINXManager:
    """Manages NGINX configuration files and reloads."""

    def __init__(self):
        self.sites_available = Path(settings.nginx_sites_available)
        self.sites_enabled = Path(settings.nginx_sites_enabled)
        self.nginx_bin = settings.nginx_bin
        self.last_reload_timestamp: Optional[datetime] = None
        self.last_reload_status: bool = True

    def generate_config(self, config: ProxyConfig) -> str:
        """Generate NGINX configuration content for a proxy."""
        upstream_url = f"http://{config.upstream_host}:{config.upstream_port}"

        if config.ssl_enabled:
            # HTTPS configuration with HTTP redirect
            nginx_config = f"""# Proxy configuration for {config.droplet_name}
# Generated by Proxy Manager at {datetime.utcnow().isoformat()}

server {{
    listen 80;
    server_name {config.domain};

    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}}

server {{
    listen 443 ssl http2;
    server_name {config.domain};

    # SSL certificates (managed by certbot)
    ssl_certificate /etc/letsencrypt/live/{config.domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{config.domain}/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Proxy settings
    location / {{
        proxy_pass {upstream_url};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        proxy_send_timeout 300;
    }}
}}
"""
        else:
            # HTTP-only configuration
            nginx_config = f"""# Proxy configuration for {config.droplet_name}
# Generated by Proxy Manager at {datetime.utcnow().isoformat()}

server {{
    listen 80;
    server_name {config.domain};

    # Proxy settings
    location / {{
        proxy_pass {upstream_url};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        proxy_send_timeout 300;
    }}
}}
"""

        return nginx_config

    def get_config_path(self, droplet_name: str) -> Path:
        """Get the path to the config file for a droplet."""
        return self.sites_available / f"fpai-{droplet_name}.conf"

    def get_enabled_path(self, droplet_name: str) -> Path:
        """Get the path to the enabled symlink for a droplet."""
        return self.sites_enabled / f"fpai-{droplet_name}.conf"

    def write_config(self, config: ProxyConfig) -> Tuple[bool, Optional[str]]:
        """
        Write NGINX configuration to file.

        Returns:
            Tuple of (success, error_message)
        """
        try:
            config_path = self.get_config_path(config.droplet_name)
            nginx_config = self.generate_config(config)

            # Ensure directories exist
            self.sites_available.mkdir(parents=True, exist_ok=True)
            self.sites_enabled.mkdir(parents=True, exist_ok=True)

            # Write config file
            config_path.write_text(nginx_config)
            logger.info(f"Wrote NGINX config for {config.droplet_name} to {config_path}")

            # Create symlink in sites-enabled
            enabled_path = self.get_enabled_path(config.droplet_name)
            if enabled_path.exists() or enabled_path.is_symlink():
                enabled_path.unlink()

            enabled_path.symlink_to(config_path)
            logger.info(f"Created symlink {enabled_path} -> {config_path}")

            return True, None

        except Exception as e:
            error_msg = f"Failed to write config: {str(e)}"
            logger.error(error_msg)
            return False, error_msg

    def test_config(self) -> Tuple[bool, str]:
        """
        Test NGINX configuration.

        Returns:
            Tuple of (success, output)
        """
        try:
            result = subprocess.run(
                [self.nginx_bin, "-t"],
                capture_output=True,
                text=True,
                timeout=10,
            )

            output = result.stderr + result.stdout
            success = result.returncode == 0

            if success:
                logger.info("NGINX config test passed")
            else:
                logger.error(f"NGINX config test failed: {output}")

            return success, output

        except subprocess.TimeoutExpired:
            error_msg = "NGINX config test timed out"
            logger.error(error_msg)
            return False, error_msg
        except Exception as e:
            error_msg = f"Failed to test NGINX config: {str(e)}"
            logger.error(error_msg)
            return False, error_msg

    def reload(self) -> Tuple[bool, str]:
        """
        Reload NGINX.

        Returns:
            Tuple of (success, output)
        """
        try:
            result = subprocess.run(
                [self.nginx_bin, "-s", "reload"],
                capture_output=True,
                text=True,
                timeout=10,
            )

            output = result.stderr + result.stdout
            success = result.returncode == 0

            self.last_reload_timestamp = datetime.utcnow()
            self.last_reload_status = success

            if success:
                logger.info("NGINX reloaded successfully")
            else:
                logger.error(f"NGINX reload failed: {output}")

            return success, output

        except subprocess.TimeoutExpired:
            error_msg = "NGINX reload timed out"
            logger.error(error_msg)
            self.last_reload_status = False
            return False, error_msg
        except Exception as e:
            error_msg = f"Failed to reload NGINX: {str(e)}"
            logger.error(error_msg)
            self.last_reload_status = False
            return False, error_msg

    def delete_config(self, droplet_name: str) -> Tuple[bool, Optional[str]]:
        """
        Delete NGINX configuration for a droplet.

        Returns:
            Tuple of (success, error_message)
        """
        try:
            config_path = self.get_config_path(droplet_name)
            enabled_path = self.get_enabled_path(droplet_name)

            # Remove symlink
            if enabled_path.exists() or enabled_path.is_symlink():
                enabled_path.unlink()
                logger.info(f"Removed symlink {enabled_path}")

            # Remove config file
            if config_path.exists():
                config_path.unlink()
                logger.info(f"Removed config file {config_path}")

            return True, None

        except Exception as e:
            error_msg = f"Failed to delete config: {str(e)}"
            logger.error(error_msg)
            return False, error_msg

    def list_configs(self) -> list[str]:
        """List all managed proxy configurations."""
        try:
            configs = []
            for config_file in self.sites_available.glob("fpai-*.conf"):
                # Extract droplet name from filename
                droplet_name = config_file.stem.replace("fpai-", "")
                configs.append(droplet_name)

            return configs

        except Exception as e:
            logger.error(f"Failed to list configs: {str(e)}")
            return []

    def is_nginx_available(self) -> bool:
        """Check if NGINX is available."""
        return Path(self.nginx_bin).exists()

    def is_config_dir_writable(self) -> bool:
        """Check if config directory is writable."""
        try:
            return os.access(self.sites_available, os.W_OK)
        except Exception:
            return False
